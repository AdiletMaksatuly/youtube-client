{"ast":null,"code":"import { SimpleChanges } from '@angular/core';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../../services/youtube.service\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"../search-item/search-item.component\";\nimport * as i4 from \"../../../pipes/search-filter.pipe\";\n\nfunction SearchResultsComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 2);\n    i0.ɵɵelement(1, \"app-search-item\", 3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const video_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"video\", video_r1);\n  }\n}\n\nexport let SearchResultsComponent = /*#__PURE__*/(() => {\n  class SearchResultsComponent {\n    constructor(youtubeService) {\n      this.youtubeService = youtubeService;\n      this.searchQuery = '';\n      this.filterQuery = null;\n      this.filterString = '';\n      this.videos = [];\n    }\n\n    ngOnInit() {\n      this.getVideos();\n    }\n\n    ngOnChanges(changes) {\n      // if searchQuery is the prop that triggered event, then do not sort\n      if (changes['searchQuery']) return;\n      this.doSort(this.videos);\n    }\n\n    getVideos() {\n      this.youtubeService.getVideos().subscribe(videos => this.videos = videos);\n    }\n\n    doSort(videosToSort) {\n      if (this.filterQuery?.date) {\n        this.sortByDate(videosToSort, this.filterQuery.date);\n      }\n\n      if (this.filterQuery?.countOfViews) {\n        this.sortByCountOfViews(videosToSort, this.filterQuery.countOfViews);\n      }\n    }\n\n    sortByDate(videosToSort, filterOrder) {\n      this.videos = videosToSort.sort((videoA, videoB) => {\n        const videoADate = new Date(videoA.snippet.publishedAt);\n        const videoBDate = new Date(videoB.snippet.publishedAt); // old date's ms is bigger than earlier date's ms, so when ascending, earlier date with less ms must be before old date. so, difference must be B - A.\n        // when descending, vice versa\n\n        return filterOrder === 'ascending' ? +videoBDate - +videoADate : +videoADate - +videoBDate;\n      });\n    }\n\n    sortByCountOfViews(videosToSort, filterOrder) {\n      this.videos = videosToSort.sort((videoA, videoB) => {\n        const videoAViews = videoA.statistics.viewCount;\n        const videoBViews = videoB.statistics.viewCount;\n        return filterOrder === 'ascending' ? +videoAViews - +videoBViews : +videoBViews - +videoAViews;\n      });\n    }\n\n  }\n\n  SearchResultsComponent.ɵfac = function SearchResultsComponent_Factory(t) {\n    return new (t || SearchResultsComponent)(i0.ɵɵdirectiveInject(i1.YoutubeService));\n  };\n\n  SearchResultsComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: SearchResultsComponent,\n    selectors: [[\"app-search-results\"]],\n    inputs: {\n      searchQuery: \"searchQuery\",\n      filterQuery: \"filterQuery\",\n      filterString: \"filterString\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 5,\n    consts: [[1, \"search-results\"], [\"class\", \"search-results-item\", 4, \"ngFor\", \"ngForOf\"], [1, \"search-results-item\"], [3, \"video\"]],\n    template: function SearchResultsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ul\", 0);\n        i0.ɵɵtemplate(1, SearchResultsComponent_li_1_Template, 2, 1, \"li\", 1);\n        i0.ɵɵpipe(2, \"searchFilter\");\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind3(2, 1, ctx.videos, ctx.searchQuery, ctx.filterString));\n      }\n    },\n    dependencies: [i2.NgForOf, i3.SearchItemComponent, i4.SearchFilterPipe],\n    styles: [\".search-results[_ngcontent-%COMP%]{display:grid;grid-template-columns:repeat(4,1fr);gap:20px}\"]\n  });\n  return SearchResultsComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}